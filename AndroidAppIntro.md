1. Android应用程序的组成部分
Android 应用程序由松散耦合的组件构成，并使用应用程序Manifest绑定到一起；应用程序Manifest描述了每一个组件和他们之间交互的方式，还用于指定应用程序的元数据，其硬件和平台要求，外部库以及必需的权限。
以下几个组件提供了应用程序的基本结构模块：
	1. Activity 应用程序的表示层。应用程序中的每一个UI都是通过Activity类的一个或多个扩展实现的。Activity使用Fragment和视图来布局和显式信息，以及响应用户动作。在桌面开发环境中，Activity就相当于Form。
	2. Service 应用程序中不可见的工作者。Service组件在运行时没有UI，它们可以更新数据源和Activity，触发通知和广播Intent。它们被用来执行一些运行时间长的任务，或者不需要用户交互的任务（例如，即使当应用程序的Activity不是活动的或者可见的时候也需要继续进行的网络查找或其他网络任务）。
	3. Content Provider 一个可共享的持久数据存储器。Content Provider用来管理和持久化应用程序数据，通常会与SQL数据库交互。Content Provider是在应用程序之间共享数据的首选方法。可以通过配置自己的Content Provider来允许其他应用程序访问，也可以访问其他应用程序提供的Content Provider。 Android设备包含了多个本地Content Provider来提供有用的数据库，如媒体库和联系人信息等。
	4. Intent 一个强大的应用程序间的消息传递框架。Android中大量使用了Intent。Intent可以用来启动和停止Activity和Service。在系统范围内或向目标Activity，Service或Broadcast Receiver广播消息，以及请求对特定的一条数据执行操作。
	5. Broadcast Receiver Intent侦听器。Broadcast Receiver使应用程序可以监听那些匹配指定的过滤标准的Intent广播。Broacast Receiver会自动地启动应用程序来响应某个收到的Intent，这个特点使它们成为了事件驱动的应用程序的最佳选择。
	6. Widget 通常添加设备到设备的主屏幕的可视化应用程序组件。Widget是Broadcast Receiver的特殊变体，可用于创建动态的交互式应用程序组件，用户可以把这些组件添加到他们的主屏幕上。
	7. Notification Notification允许向用户发送信号，但却不会过分吸引它们的注意力或者打断它们当前的Activity。它们是应用程序不可见或者不活动（特别是Service 或者Broadcast Receiver）吸引用户注意的首选方法。

2. 应用程序的Manifest
	1. 每个Android项目都包含一个Manifest文件 ----- Android Manifest.xml，它存储在项目层次中的最底层。Manifest可以定义引用程序及其组件和需求的结构和元数据。
	2. 它包含了组成应用程序的每一个Activity，Services，Content Provider，和Broadcast Receiver的节点，并使用Intent Filter和权限来确定这些组件之间以及这些组件和其他应用程序是如何交互的。
	3. Manifest 文件还可以用来指定应用程序的元数据（如它的图标，版本号或者主题）以及额外的顶层节点，这些节点可以用来指定必需的安全权限和单元测试，以及定义硬件，屏幕和平台支持要求。
	4. Manifest 文件由一个根manifest标签构成，该标签带有一个被设为项目包的package属性。它通常包含一个xmlns:android属性来提供文件内使用的某些系统属性。
	5. 使用versionCode属性可将当前的应用程序版本号定义为一个整数，每次版本迭代时，这个数字都会增加。使用versionName可以定义一个显示给用户的公共版本号。
	6. 通过使用installLocaton属性，这可以指定是否允许将应用程序安装到外部存储器而不是内部存储器上。为此可以将其指定为preferExternal或auto，使用前者时，只要有可能就会把应用程序安装到外部存储器上，后者则要求系统决定。
	7. application节点： 
		一个Manifest只能包含一个application节点。它使用各种属性来指定应用程序的各种元数据(包括标题，图标和主题）。在开发时，应该包含一个设置为true的debuggable属性以启用调试，但是在发布时可以禁用该属性。
		application节点还可以作为一个包含了Activity，Service，Content Provider和Broadcast Receiver节点的容器，它包含的这些节点指定了应用程序的组件。使用android:name属性可以指定自定义Application类的名称。
	8. Activity 节点：
		应用程序内的每一个Activity都要求有一个activity标签，并使用android:name属性来指定Activity类的名称。必须包含核心的启动Activity和其他所有可以显示的Activity。启动任何一个没有在Manifest中定义的Activity时都会抛出一个运行时异常。每一个Activity节点都允许使用intent-filter子标签来定义用于启动该Activity的Intent。同样要注意，在指定Activity的类名时，可以使用句点号作为简写方式代替应用程序的包名。
	9. service 和activity标签一样，需要为应用程序中使用的每一个Service类添加一个service标签。service标签页支持使用intent-filter子标签来允许运行时迟邦定。
	10. provider 
		provider标签用来指定应用程序中的每一个Content Provider。 Content Provider用来管理数据库访问和共享。
	11. receiver 
		通过添加receiver标签，可以注册一个Broadcast Receiver，而不用事先启动应用程序。
		Broadcast Receiver就像全局事件监听器一样，一旦注册了之后，无论何时，只要与它相匹配的Intent被系统或应用程序广播出来，它就会立即执行。通过在Manifest中注册一个Broadcast Receiver，可以使这个进程实现完全自治。如果一个匹配的Intent被广播了，则应用程序就会自动启动，并且你注册的Broadcast Receiver也会开始运行。
		每个receiver节点都被允许使用intent-filter子标签来定义可以用来触发接收器的Intent。

3. 分离资源
	1. 把非代码资源(如图片和字符串常量)和代码分离开来始终是一种好的做法。Android支持各种资源与代码的分离，从简单的字符串和颜色这样的值到更复杂的资源，例如图片（drawable)，动画，主题和菜单。
	2. 也许可以分离的最复杂的资源就是布局。
	3. 通过将资源分离开来，可以使它们更容易维护，更新和管理。这也可以让你轻松地定义多种可选的资源值来支持国际化需求，以及包含不同的资源来支持硬件的变化，特别是屏幕尺寸和分辨率的变化。
	4. 应用程序资源存储在项目层次中的res文件夹下。在整个文件夹中，每一种可用的资源类型都存储在各自的子文件夹中。
	5. 每种资源类型存储在不同的文件夹中，这些资源类型分别是：简单的值，Drawable，颜色，布局，动画，样式，菜单，XML，文件（包括searchable）和原始资源。
	6. 当构建应用程序的时候，这些资源会被尽可能高效地编译和压缩，并包含到应用程序包中。这个过程中还创建一个R类文件，它包含了对加入到该项目中的每一个资源的引用，因此可以在代码中引用资源，其优势在于可以在设计时检查语法。
	7. 在所有的情况下，资源文件名都应该只包含小写字母，数字，点(.)和下划线(_)。
	8. 习惯上会将资源的每一种类型存储到单独的文件夹中，例如：res/values/strings.xml就只包含字符串资源。
	9. 布局资源：
		布局资源可以让你在XML文件中设计用户界面，而不是在代码中构建它们，从而可以把表示层从业务逻辑中分离出来。
		布局可以用来定义任何可视化组件（包括Activity, Fragment和Widget）的用户界面。一旦在XML文件中进行了定义，就必须把布局填充（inflat）到用户界面中。在Activity中，这是使用setContentView完成的（通常在onCreate方法中进行），而Fragment视图则是使用传入Fragment的onCreateView处理程序的Inflator对象的inflate方法完成填充的。
		在Android中，使用布局在XML文件中创建自己的屏幕是一种最佳实践。布局和代码的分离可以让你为不同的硬件配置创建优化的布局。
		每一个布局的定义都存储在res/layout文件夹下的一个单独的文件中，每一个文件都包含一个单独的布局，文件名就是它的资源标识符。

	10. 菜单资源：
		创建菜单资源并使用XML设计菜单布局，而不是在代码中创建菜单。
		菜单资源可以用来定义应用程序内的Activity和上下文菜单。它们可以提供与使用代码构建菜单时具有相同的选项。在XML中定义菜单以后，将可以通过使用Menuinflator Service的inflate方法（通常位于onCreateOptionsMenu方法中）把菜单“填充”到应用程序中。
		每个菜单定义都存储在res/menu文件夹下的一个单独文件中，每个文件都只包含一个菜单。文件名就是菜单的资源标识符。
		在Android中，使用XML定义菜单是一种最佳设计实践。
4. 使用资源：
	1. 除了你提供的资源以外，Android平台提供了多个系统资源供在应用程序中使用。既可以在应用程序代码中直接使用这些资源，也可以在其他资源中引用这些资源（例如，在一个布局定义中就可以应用一个尺寸资源）。
	2. 当使用资源的时候，不能选择特定的专用版本。Android会基于当前的硬件，设备和语言配置来为某个资源标识符选择最合适的值。
	3. 在代码中使用资源： 
		可以在代码中使用静态R类来访问资源。R类是基于外部资源而生成的类。并且是在编译项目时创建的。对于已为其定义了至少一个资源的资源类型，R类将对应地包含一个静态子类。例如，默认的新项目中就包含R.string和R.drawable子类。
		R中的每一个子类都把它的相关资源表示为变量的形式，变量的名字与资源标识符相匹配 ---- 例如，R.string.app_name, 或者R.drawable.icon。这些变量的值是一个整数，代表每个资源在资源表中的位置，而不是本身的一个实例。
		当一个构造函数或者方法（如setContentView）接受一个资源标识符时，就可以传递资源变量。
		当需要一个资源本身的实例时，就需要使用辅助方法来把他们从资源表中提取出来。在应用程序中，资源表被表示为Resources类的一个实例。
		因为这些辅助方法将在应用程序的当前资源表中进行查找，所以它们不能是静态的。可以在应用程序的上下文中使用getResources方法来访问应用程序的Resources实例。
		Resources 类为每一个可用的资源类型包含了gettter，并且通常是通过传递你需要的资源实例的资源ID来发挥作用的。
	4. 在资源内引用资源:
		也可以引用一个资源并把它作为其他XML资源中的属性值。
		这对布局和样式特别有用，它允许创建主题的某种特定变化形式以及本地字符串和图片资源。它也是一种使布局支持不同的图像和空间的非常有用的方式，这样可以保证布局能针对不同的屏幕大小和分辨率进行优化。
		使用@符号，就可以在一个资源中引用另一个资源。
		默认情况下，Android会认为郑在使用的是同一个包中的资源，所以如果使用的是其他包中的资源，那么就需要完全限定包的名称。
	5. 使用系统资源：
		Android框架提供了许多本地资源，包括各种各样的字符串，图片，动画，样式和布局供你在应用程序中使用。
		在代码中使用系统资源的方法和使用自己的资源的方法相似。不同的是，你要使用android类中可用的本地Android资源类，而不是使用应用程序特定R类。
		要在XML中访问系统资源，需要指定android作为包的名称。
	6. 在当前的主题中引用样式：
		主题是保证应用程序样式UI一致性的非常好的方法。Android提供一种捷径，可以使用当前应用的主题中样式，而不是完全定义一个新的样式。
		要实现上述目标，需要使用?android:而不是@来作为想要使用的资源的前缀。
		这种技术可以创建出随当前主题改变而改变的样式，而不必对每一个单独的样式资源进行修改。

5. Android Application类简介
	1. 每次应用程序运行时，应用程序的Application类都保持实例化状态。与Activity不同，配置的改变并不会导致应用程序重启。通过扩展Application类，可以完成以下3项工作：
		A. 对Android运行时广播的应用程序级事件（如低内存）做出响应。
		B. 在应用程序组件间传递对象。
		C. 管理和维护多个应用程序组件使用的资源。
	其中，后两项工作通过使用一个单态类能够更好地完成。当在Manifest中注册了Application实现以后，它会在创建应用程序进程的时候得到实例化。因此，Application的实现在本质上是单实例的。并且应该作为单态进行实现，以便提供对其方法和成员变量的访问。
	2. 在创建新的Application类后，必须使用一个name属性在Manifest的application节点中注册它。
	3. 当应用程序开始运行的时候，Application实现将会得到实例化。创建新的状态变量和全局变量以便从应用程序组件中进行访问。

6. 重写应用程序的生命周期事件
	1. Application类为应用程序的创建和终止，低可用内存和配置改变提供了事件处理程序。通过重写以下这些方法，可以为上述几种情况实现自己的应用程序行为：
		A.onCreate 在创建应用程序时调用。可以重写这个方法来实例化应用程序单态，以及创建和实例化任何应用程序状态变量或共享资源。
		B. onLowMemory 当系统处于资源匮乏的状态时，具有良好行为的应用程序可以释放额外的内存。这个方法一般只会在后台进程已经终止，但是前台应用程序仍然缺少内存时调用。可以重写这个处理程序来清空缓存或者释放不必要的资源。
		C. onTrimMemory 作为onLowMemory的一个特定于应用程序的替代选择，在Android 4.0中引入。当运行时决定当前应用程序应该尝试减少其内存开销时调用。它包含一个level参数，用于提供请求的上下文。
		D. onConfigurationChanged 与Activity不同，在配置改变时，应用程序对象不会被终止和重启。如果应用程序使用的值依赖于特定的配置，则重写这个方法来重新加载这些值，或者在应用程序级别处理配置改变。
	必须在重写这些方法时调用超类的事件处理程序。

7.  深入探讨Android Activity
	1. 每一个Activity都表示一个屏幕，应用程序会把它呈现给用户。应用程序越多需要的屏幕可能就越多。
	2. 典型情况下，这至少包括一个用来处理应用程序的主UI功能的主界面屏幕，这个主界面一般由许多Fragment组成，并且通常是由一组次要Activity支持的。要在屏幕之间进行切换，就不许要启动一个新的Activity(或者从一个Activity返回)。
	3. 大部分Activity都被设计为占据整个显示屏，但是也可以创建半透明的或者浮动的Activity。
	4. 要创建一个新的Activity，需要对Activity类进行扩展，在新类定义用户界面并实现新的功能。
	5. 基本Activity类呈现了一个封装了窗口显示处理功能的空白屏幕。一个空Activity并不是特别有用，所以希望做的第一件事应该是使用Fragment，布局和视图来创建UI。
	6. 视图(VIEW)是用来显示数据和提供用户交互的UI空间。Android提供了多个布局类，称为ViewGroup，它可以包含多个视图(VIEW)来帮助布局UI。
	7. Fragment用来封装UI的各个部分，从而能够方便地创建动态界面，这些界面能够针对不同的屏幕尺寸和方向重新排列，起到优化UI布局的效果。
	8. 要把一个UI分配给一个Activity，需要在Activty的onCreate方法中调用setContentView。
	9. 更多情况下，将会使用到一个更加复杂的UI设计，可以在代码中使用布局ViewGroup来创建布局，或者可以使用标准的Android约定，传递外部资源中定义的布局资源ID。
	10. 为了在应用程序中使用一个Activity，需要在Manifest中对其进行注册。在Manifest中的Application节点内添加新的activity标签：activity标签包含像标签，图标，必须的权限以及Activity所使用的主题这样的元数据的属性。没有对应的activity标签的Activity是不能被显示的，试图显示它们会导致抛出一个运行时异常。
	11. 在activity标签中，可以添加intent-filter节点来指定能够用来启动该Activity的Intent。
	12. 每一个Intent Filter都定义了一个或者多个Activity所支持的动作或者分类。
	13. 要想让一个Acivity可以被应用程序启动器所使用，它必须包含一个监听MAIN动作和LAUNCHERE分类的Intent Filter。
